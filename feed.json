{
	"version": "https://jsonfeed.org/version/1",
	"title": "Jay Lyerly",
	"icon": "https://micro.blog/jaylyerly/avatar.jpg",
	"home_page_url": "https://www.bugsandbunnies.org/",
	"feed_url": "https://www.bugsandbunnies.org/feed.json",
	"items": [
		
			{
				"id": "http://jaylyerly.micro.blog/2021/08/04/twos-company-get.html",
				
				"content_html": "<p>Twoâ€™s company. Get lost nerd.</p>\n\n<p><img src=\"uploads/2021/35869d6666.jpg\" width=\"600\" height=\"450\" alt=\"\" /></p>\n",
				"content_text": "Twoâ€™s company. Get lost nerd. \n\n<img src=\"uploads/2021/35869d6666.jpg\" width=\"600\" height=\"450\" alt=\"\" />\n",
				"date_published": "2021-08-04T21:42:00-04:00",
				"url": "https://www.bugsandbunnies.org/2021/08/04/twos-company-get.html",
				"tags": ["Rabbit"]
			},
			{
				"id": "http://jaylyerly.micro.blog/2021/08/04/the-mysterious-error.html",
				"title": "The MYSTERIOUS Error.",
				"content_html": "<p>Callisto is a Catalyst app, mostly running iOS style code on a Mac.  But there are some things that Catalyst apps can&rsquo;t do &ndash; like run a python server as another process.  But Mac apps can!</p>\n\n<p>There are a lot of instructions around the Internet about how to use AppKit code within your Catalyst app to do those Mac things that Catalyst doesn&rsquo;t cover yet.  <a href=\"https://www.highcaffeinecontent.com/blog/20190607-Beyond-the-Checkbox-with-Catalyst-and-AppKit\">This article</a> from Steve Troughton-Smith was our guide.</p>\n\n<p>We also want to do auto-updates like a regular Mac app.  We&rsquo;re distributing outside the Mac App Store for Reasons, so we&rsquo;re in charge of our own updates.  Yep, dear reader, that means <a href=\"https://sparkle-project.org\">Sparkle</a>, which should be fine, right?  So we get the Sparkle framework and link it in to our AppKit bundle which is a plugin for our main app.  Compile, run and ðŸ’¥.  This error is staring at us from the console.</p>\n\n<pre><code>code signature in (&lt;full path redacted&gt;/Sparkle.framework/Versions/A/Sparkle) not valid for use \nin process using Library Validation: not allowing mapping of development code into production process\n</code></pre>\n\n<p>What does <em>that</em> mean?  After some furious googling, we&rsquo;re left empty handed and confused.  The worst kind of error is that special, <em>new</em> error that no one else has ever seen.  Bollocks.</p>\n\n<p>After some futile futzing around in the dark, I give up and burn a &lsquo;code level&rsquo; support ticket with Apple.  I send a fairly detailed outline of the problem and the next morning I get back a nice response asking for more details.  In particular, how are the app and the framework code signed?  (You can check that with <code>codesign -vvvd &lt;.app or .framework&gt;</code>.)</p>\n\n<p>And immediately, I see it.</p>\n\n<p>App Signature:</p>\n\n<p><code>Authority=Developer ID Application: Oak City Labs, LLC (XXXXXXXXX)</code></p>\n\n<p>Framework Signature:</p>\n\n<p><code>Authority=Apple Development: Continuous Integration (YYYYYYYYY)</code></p>\n\n<p>The app is signed with a <em>production</em> identity while the framework is signed with a <em>development</em> identity.  That&rsquo;s what that weird error meant about <code>not allowing mapping of development code into production process</code>.  The <code>codesign</code> docs point out how frameworks and apps need to both be signed with the same Team ID (which I checked), but don&rsquo;t mention this distinction between production / development signing identities.</p>\n\n<p>I update Xcode so that the AppKit bundle was being signed with the same production identity and all is well!  We are fully Sparkle enabled!  Curiously, the AppKit bundle has always been signed with the development identity before, yet it loaded fine at runtime.  That must be one of those fine distinctions between a bundle and a framework that I don&rsquo;t quite understand.</p>\n\n<p>But now we celebrate!  ðŸŽ‰ðŸŽ‰ðŸŽ‰</p>\n",
				"content_text": "Callisto is a Catalyst app, mostly running iOS style code on a Mac.  But there are some things that Catalyst apps can't do -- like run a python server as another process.  But Mac apps can! \n\nThere are a lot of instructions around the Internet about how to use AppKit code within your Catalyst app to do those Mac things that Catalyst doesn't cover yet.  [This article](https://www.highcaffeinecontent.com/blog/20190607-Beyond-the-Checkbox-with-Catalyst-and-AppKit) from Steve Troughton-Smith was our guide.\n\nWe also want to do auto-updates like a regular Mac app.  We're distributing outside the Mac App Store for Reasons, so we're in charge of our own updates.  Yep, dear reader, that means [Sparkle](https://sparkle-project.org), which should be fine, right?  So we get the Sparkle framework and link it in to our AppKit bundle which is a plugin for our main app.  Compile, run and ðŸ’¥.  This error is staring at us from the console.\n\n```\ncode signature in (<full path redacted>/Sparkle.framework/Versions/A/Sparkle) not valid for use \nin process using Library Validation: not allowing mapping of development code into production process\n```\n\nWhat does _that_ mean?  After some furious googling, we're left empty handed and confused.  The worst kind of error is that special, _new_ error that no one else has ever seen.  Bollocks.  \n\nAfter some futile futzing around in the dark, I give up and burn a 'code level' support ticket with Apple.  I send a fairly detailed outline of the problem and the next morning I get back a nice response asking for more details.  In particular, how are the app and the framework code signed?  (You can check that with `codesign -vvvd <.app or .framework>`.)\n\nAnd immediately, I see it.  \n\nApp Signature:\n\n`Authority=Developer ID Application: Oak City Labs, LLC (XXXXXXXXX)`\n\nFramework Signature:\n\n`Authority=Apple Development: Continuous Integration (YYYYYYYYY)`\n\nThe app is signed with a _production_ identity while the framework is signed with a _development_ identity.  That's what that weird error meant about `not allowing mapping of development code into production process`.  The `codesign` docs point out how frameworks and apps need to both be signed with the same Team ID (which I checked), but don't mention this distinction between production / development signing identities.\n\nI update Xcode so that the AppKit bundle was being signed with the same production identity and all is well!  We are fully Sparkle enabled!  Curiously, the AppKit bundle has always been signed with the development identity before, yet it loaded fine at runtime.  That must be one of those fine distinctions between a bundle and a framework that I don't quite understand.\n\nBut now we celebrate!  ðŸŽ‰ðŸŽ‰ðŸŽ‰\n\n\n",
				"date_published": "2021-08-04T09:24:31-04:00",
				"url": "https://www.bugsandbunnies.org/2021/08/04/the-mysterious-error.html"
			},
			{
				"id": "http://jaylyerly.micro.blog/2021/08/04/throw-some-results.html",
				"title": "Throw some Results ",
				"content_html": "<p>Errors, we&rsquo;ve all got &lsquo;em.  What do we do with &lsquo;em?</p>\n\n<p>Swift has a couple of different error handling patterns.  There&rsquo;s <code>try</code> and <code>catch</code> which I always think of as kind of the nuclear option.  Something went wrong, the code blows up with a <code>throw</code> and our hero, the intrepid programmer, has to deal with it right here, right now.  And then there&rsquo;s <code>Result</code>, an elegant weapon for a more civilized age.  Call a method and get back a <code>Result</code>, then deal with it as you like &ndash; check for the value, handle the error or maybe even ignore it altogether.  Depending on your situation, one of these is likely to suit better than the other.</p>\n\n<p>But sometimes the situation changes.  Maybe you wrote some code that should obviously <code>throw</code>(or calls some library code that <code>throws</code>), but it would really make a lot more sense to return a <code>Result</code>.  As it turns out, it&rsquo;s really easy to convert between <code>try</code>/<code>catch</code> and a <code>Result</code> type.</p>\n\n<p>Imagine you have some code that can <code>throw</code>.  Maybe even it always throws, because it is a <code>badIdea()</code>.  But you need to have a <code>Result</code> instance instead.  The <code>Result</code> type has an initializer that handles this perfectly.  You hand it a closure that returns the <code>Success</code> type for the <code>Result</code> and any error thrown by the closure is used for the <code>Failure</code> case.  Basically, they&rsquo;ve wrapped up all the boilerplate in this initializer, and you get a very concise way to convert <code>try</code> into a <code>Result</code>.</p>\n\n<pre><code class=\"language-swift\">enum HorrendousError: Error {\n    case veryBad\n}\n\nfunc badIdea() throws -&gt; String {\n    throw HorrendousError.veryBad\n}\n\nlet result = Result&lt;String, Error&gt; { try badIdea() }\n\n</code></pre>\n\n<p>The full signature of that initializer is <code>Result.init(catching: () -&gt; Success)</code>.  The single argument is a closure returns the <code>Success</code> type &ndash; here that&rsquo;s a <code>String</code>.  If the closure throws, then that gets wrapped up as the <code>.failure</code> case.</p>\n\n<p>How about doing the reverse?  You&rsquo;ve got a result type, but you&rsquo;d rather access the value in a <code>try</code> / <code>catch</code> sort of way.  The <code>Result</code> type itself has a accessor method for just such an occasion!</p>\n\n<pre><code class=\"language-swift\">let value = try someResult.get()\n</code></pre>\n\n<p>If the <code>Result</code> type is the <code>.success</code> case, it just returns the successful value.  If <code>someResult</code> is a <code>.failure</code> case, the <code>get()</code> method will <code>throw</code>.  This is especially useful if you want to access the result and ignore any errors:</p>\n\n<pre><code class=\"language-swift\">let optionalValue = try? someResult.get()\n</code></pre>\n\n<p>This is also handy in testing when you expect a <code>Result</code> type to be successful.  Use the <code>get()</code> method to access the value and let <code>XCTest</code>&rsquo;s support for tests that <code>throw</code> to handle the error cases.  This can make tests shorter and easier to read too.</p>\n\n<p>For me, discovering the interchangeable nature of <code>try</code>/<code>catch</code> and the <code>Result</code> type was a bit of an &lsquo;aha!&rsquo; moment.  You&rsquo;re not locked in to on type of error handling or another.  With these convenient converters, you can fluidly move from one type to another as needed.  And without a lot of boilerplate code for the conversions!</p>\n",
				"content_text": "Errors, we've all got 'em.  What do we do with 'em?\r\n\r\nSwift has a couple of different error handling patterns.  There's `try` and `catch` which I always think of as kind of the nuclear option.  Something went wrong, the code blows up with a `throw` and our hero, the intrepid programmer, has to deal with it right here, right now.  And then there's `Result`, an elegant weapon for a more civilized age.  Call a method and get back a `Result`, then deal with it as you like -- check for the value, handle the error or maybe even ignore it altogether.  Depending on your situation, one of these is likely to suit better than the other.\r\n\r\nBut sometimes the situation changes.  Maybe you wrote some code that should obviously `throw`(or calls some library code that `throws`), but it would really make a lot more sense to return a `Result`.  As it turns out, it's really easy to convert between `try`/`catch` and a `Result` type.\r\n\r\nImagine you have some code that can `throw`.  Maybe even it always throws, because it is a `badIdea()`.  But you need to have a `Result` instance instead.  The `Result` type has an initializer that handles this perfectly.  You hand it a closure that returns the `Success` type for the `Result` and any error thrown by the closure is used for the `Failure` case.  Basically, they've wrapped up all the boilerplate in this initializer, and you get a very concise way to convert `try` into a `Result`.\r\n\r\n\r\n```swift\r\nenum HorrendousError: Error {\r\n    case veryBad\r\n}\r\n\r\nfunc badIdea() throws -> String {\r\n    throw HorrendousError.veryBad\r\n}\r\n\r\nlet result = Result<String, Error> { try badIdea() }\r\n\r\n```\r\n\r\nThe full signature of that initializer is `Result.init(catching: () -> Success)`.  The single argument is a closure returns the `Success` type -- here that's a `String`.  If the closure throws, then that gets wrapped up as the `.failure` case. \r\n\r\nHow about doing the reverse?  You've got a result type, but you'd rather access the value in a `try` / `catch` sort of way.  The `Result` type itself has a accessor method for just such an occasion!\r\n\r\n```swift\r\nlet value = try someResult.get()\r\n```\r\n\r\nIf the `Result` type is the `.success` case, it just returns the successful value.  If `someResult` is a `.failure` case, the `get()` method will `throw`.  This is especially useful if you want to access the result and ignore any errors:\r\n\r\n```swift\r\nlet optionalValue = try? someResult.get()\r\n```\r\n\r\nThis is also handy in testing when you expect a `Result` type to be successful.  Use the `get()` method to access the value and let `XCTest`'s support for tests that `throw` to handle the error cases.  This can make tests shorter and easier to read too.\r\n\r\nFor me, discovering the interchangeable nature of `try`/`catch` and the `Result` type was a bit of an 'aha!' moment.  You're not locked in to on type of error handling or another.  With these convenient converters, you can fluidly move from one type to another as needed.  And without a lot of boilerplate code for the conversions!  \n",
				"date_published": "2021-08-04T09:24:01-04:00",
				"url": "https://www.bugsandbunnies.org/2021/08/04/throw-some-results.html"
			}
	]
}
